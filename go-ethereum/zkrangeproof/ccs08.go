// Copyright 2017 ING Bank N.V.
// This file is part of the go-ethereum library.
//
// The go-ethereum library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The go-ethereum library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.

package zkrangeproof

import (
	"bytes"
	"crypto/sha256"
	"math/big"
	"crypto/rand"
	"github.com/ing-bank/zkrangeproof/go-ethereum/crypto/bn256"
	"github.com/ing-bank/zkrangeproof/go-ethereum/byteconversion"
)

/*
params contains elements generated by the verifier, which are necessary for the prover.
This must be computed in a trusted setup.
*/
type params struct {
	signatures map[string]*bn256.G2
	H *bn256.G2
	// must protect the private key
	kp keypair
}

/*
proof contains the necessary elements for the ZK proof.
*/
type proof struct {
	V,D,C *bn256.G2
	a *bn256.GT
	s,t,m,c,zsig,zv,zr *big.Int
}

/*
Commit method corresponds to the Pedersen commitment scheme. Namely, given input 
message x, and randomness r, it outputs g^x.h^r.
*/
func Commit(x,r *big.Int, p params) (*bn256.G2, error) {
	var (
		C *bn256.G2
	)
	C = new(bn256.G2).ScalarBaseMult(x)
	C.Add(C, new(bn256.G2).ScalarMult(p.H, r))
	return C, nil
}

/*
Hash is responsible for the computing a Zp element given an element from G2 and GT.
*/
func Hash(a *bn256.GT, D *bn256.G2) (*big.Int, error) {
	digest := sha256.New()
	digest.Write([]byte(a.String()))
	digest.Write([]byte(D.String()))
	output := digest.Sum(nil)
	tmp := output[0: len(output)]
	return byteconversion.FromByteArray(tmp)
}

/*
Setup generates the signature for the interval [a,b].
*/
func Setup(a, b *big.Int) (params, error) {
	var (
		i *big.Int
		p params
	)
	p.kp, _ = keygen()

	p.signatures = make(map[string]*bn256.G2)
	i = a
	for i.Cmp(b) != 0 {
		sig_i, _ := sign(i, p.kp.privk)
		p.signatures[i.String()] = sig_i 
		i = i.Add(i, new(big.Int).SetInt64(1))
	}
	h := GetBigInt("18560948149108576432482904553159745978835170526553990798435819795989606410925")
	p.H = new(bn256.G2).ScalarBaseMult(h)
	return p, nil
}

/*
Prove method is used to produce the ZKRP proof.
*/
func Prove(x,r *big.Int, p params) (proof, error) {
	var (
		v *big.Int
		A *bn256.G2
		proof_out proof
	)
	v, _ = rand.Int(rand.Reader, bn256.Order)
	// must verify if x belongs to p.signatures
	A = p.signatures[x.String()]
	proof_out.V = new(bn256.G2).ScalarMult(A, v)

	proof_out.s, _ = rand.Int(rand.Reader, bn256.Order)
	proof_out.t, _ = rand.Int(rand.Reader, bn256.Order)
	proof_out.m, _ = rand.Int(rand.Reader, bn256.Order)

	// this can be precomputed
	g1 := new(bn256.G1).ScalarBaseMult(new(big.Int).SetInt64(1))
	g2 := new(bn256.G2).ScalarBaseMult(new(big.Int).SetInt64(1))
	proof_out.a = bn256.Pair(g1, proof_out.V)
	
	proof_out.a.ScalarMult(proof_out.a, proof_out.s)
	proof_out.a.Invert(proof_out.a)
	
	bpair := bn256.Pair(g1, g2)
	bpair.ScalarMult(bpair, proof_out.t)
	proof_out.a.Add(proof_out.a, bpair)

	proof_out.C, _ = Commit(x, r, p)
	proof_out.D, _ = Commit(proof_out.s, proof_out.m, p)
	proof_out.c, _ = Hash(proof_out.a, proof_out.D)
	proof_out.c = Mod(proof_out.c, bn256.Order)

	proof_out.zsig = Sub(proof_out.s, Multiply(x, proof_out.c))
	proof_out.zsig = Mod(proof_out.zsig, bn256.Order)
	proof_out.zv = Sub(proof_out.t, Multiply(v, proof_out.c))
	proof_out.zv = Mod(proof_out.zv, bn256.Order)
	proof_out.zr = Sub(proof_out.m, Multiply(r, proof_out.c))
	proof_out.zr = Mod(proof_out.zr, bn256.Order)

	return proof_out, nil
}

/*
Verify is used to validate the ZKRP proof. It return true iff the proof is valid.
*/
func Verify(proof_out *proof, p *params, pubk *bn256.G1) (bool, error) {
	var (
		D *bn256.G2
		r1, r2 bool
		p1,p2,p3 *bn256.GT
	)
	// D == C^c.h^ zr.g^zsig ?
	D = new(bn256.G2).ScalarMult(proof_out.C, proof_out.c)
	D.Add(D, new(bn256.G2).ScalarMult(p.H, proof_out.zr)) 	
	// this can be precomputed and put in the proof
	g1 := new(bn256.G1).ScalarBaseMult(new(big.Int).SetInt64(1))
	g2 := new(bn256.G2).ScalarBaseMult(new(big.Int).SetInt64(1))
	D.Add(D, new(bn256.G2).ScalarBaseMult(proof_out.zsig)) 	

	DBytes := D.Marshal()
	pDBytes := proof_out.D.Marshal()
	r1 = bytes.Equal(DBytes, pDBytes)

	// a == [e(V,y)^c].[e(V,g)^-zsig].[e(g,g)^zv]
	p1 = bn256.Pair(pubk, proof_out.V)
	p1.ScalarMult(p1, proof_out.c)
	p2 = bn256.Pair(g1, proof_out.V)
	//p2.ScalarMult(p2, proof_out.zsig.Neg(proof_out.zsig))
	p2.ScalarMult(p2, proof_out.zsig)
	p2.Invert(p2)
	p3 = bn256.Pair(g1, g2)
	p3.ScalarMult(p3, proof_out.zv)
	
	p1.Add(p1, p2)
	p1.Add(p1, p3)
	p1.Add(p1, proof_out.a.Invert(proof_out.a))
	r2 = p1.IsOne()

	return r1 && r2, nil
}

